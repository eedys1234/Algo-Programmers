# Algo-Programmers


* 참고사항
> + 매주 일요일 오전 11시 이전까지 선택한 2문제에 대한 풀이방안 및 코드를 github와 노션에 작성
> + JAVA로 문제해결
> + 프로그래머스 문제 위주로 풀 예정

* * *

2021년 4월 1주차(2021-04-04 ~ 2021-04-10)
1) [17144번: 미세먼지 안녕!](https://www.acmicpc.net/problem/17144)
+ 풀이) 순수 구현문제로 조건을 맞춰 개발하면 되는 문제이다. 문제의 핵심은 깔끔하게 풀수 없다는 것을 인정하고 풀어야한다.

2) [코딩테스트 연습 - 타겟 넘버](https://programmers.co.kr/learn/courses/30/lessons/43165)
+ 풀이) BFS/DFS로 풀 수 있으나 BFS/DFS 가 아닌 재귀적 함수를 호출하는 방식으로 풀 수 있다. 각 배열의 원소에 대해 + 하거나 - 하는 경우의 수를 모두 탐색하는 방향으로 풀었다. 이 문제의 핵심은 모든 경우의 수를 탐색해야 문제를 풀 수 있다는 것을 알려준다.

* * *
2021년 4월 2주차(2021-04-11 ~ 2021-04-17)
1) [코딩테스트 연습 - 소수 찾기](https://programmers.co.kr/learn/courses/30/lessons/42839)
+ 풀이) 재미있는 문제다. 

1. 문자열을 각 자리수를 나타내는 정수배열로 변환
2. 정수배열을 내림차순으로 정렬
3. 배열의 크기만큼 자리수를 형성하는 가장 큰 값 구함
ex) 1,2,3 → 321
4. 가장 큰 값까지의 모든 소수 구함
5. 정수배열을 조합하였을 시 모든 경우의 수 구함
6. 모든 경우의 수에 대해서 ④에서 구했던 소수와 비교하여 소수일경우 체크 

2) [코딩테스트 연습 - 모의고사](https://programmers.co.kr/learn/courses/30/lessons/42840)
+ 풀이) 
1. 문제에서 수포자1, 2, 3이 수학문제를 찍는 순서가 반복됨을 알 수 있습니다.  
1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 

2. 각 수포자의 한 싸이클의 찍는 순서를 List에 저장합니다. for문을 통해 정답(answers) 배열을 탐색할 때 각 수포자의 찍는 순서 %연산자를 통해 순환하여 탐색하며 정답과 일치하는 개수를 Map<수포자 ID, 정답과 일치 개수>에 저장합니다.
Map을 정답과 일치하는 개수를 기준으로 내림차순 정렬한 후 일치하는 개수가 같을경우 수포자의 ID를 기준으로 오름차순 정렬합니다.

* * *
2021년 4월 3주차(2021-04-18 ~ 2021-04-24)
1. [코딩테스트 연습 - 두 개 뽑아서 더하기](https://programmers.co.kr/learn/courses/30/lessons/68644)
+ 풀이) 배열의 원소들을 모두 더하기 위해서 이중 for문을 통해 구현했습니다.
더해진 수들을 Set 자료구조에 넣어 중복되지 않도록 구현했으며, JAVA의 Tim Sort로 값들을 오름차순 정렬하였습니다.


2. [코딩테스트 연습 - 구명보트](https://programmers.co.kr/learn/courses/30/lessons/42885)
+ 풀이)
투 포인트 문제이며 보트에 탈수 있는 최대 인원이 2명인게 핵심이다.
만약 2명이 아니라면 heap을 사용해야할 것 같다.
1. people을 오름차순으로 정렬한다.
2. 가장 무게가 적은 사람을 가리키는 left, 가장 무게가 많은 사람을 가리키는 right 변수 선언한다.
3. 가장 무게가 적은 사람과 가장 많은 사람의 합이 limit보다 작은지 확인한다.
4. 만약 작다면 두 사람 모두 보트에 탈 수 있어 보트 수를 1 증가시킨다. 두 사람이 모두 탔기에 left를 1 증가시키고 right를 1 감소시킨다.
5. 만약 크다면 무게가 많은 사람만이 탈 수 있으므로 마찬가지로 보트 수를 1 증가시키며 right를 1 감소시킨다.
6. 양쪽의 변수가 교차될 때까지 반복한다.

* * *
2021년 4월 4주차(2021-04-25 ~ 2021-05-01)
1. [코딩테스트 연습 - 가장 큰 수](https://programmers.co.kr/learn/courses/30/lessons/42746)
+ 풀이) 

2. [코딩테스트 연습 - K번째수](https://programmers.co.kr/learn/courses/30/lessons/42748)
+ 풀이) 


