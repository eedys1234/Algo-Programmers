# Algo-Programmers


* 참고사항
> + 매주 일요일 오전 11시 이전까지 선택한 2문제에 대한 풀이방안 및 코드를 github와 노션에 작성
> + JAVA로 문제해결
> + 프로그래머스 문제 위주로 풀 예정

* * *

2021년 4월 1주차(2021-04-04 ~ 2021-04-10)
1) [17144번: 미세먼지 안녕!](https://www.acmicpc.net/problem/17144)
+ 풀이) 순수 구현문제로 조건을 맞춰 개발하면 되는 문제이다. 문제의 핵심은 깔끔하게 풀수 없다는 것을 인정하고 풀어야한다.

2) [코딩테스트 연습 - 타겟 넘버](https://programmers.co.kr/learn/courses/30/lessons/43165)
+ 풀이) BFS/DFS로 풀 수 있으나 BFS/DFS 가 아닌 재귀적 함수를 호출하는 방식으로 풀 수 있다. 각 배열의 원소에 대해 + 하거나 - 하는 경우의 수를 모두 탐색하는 방향으로 풀었다. 이 문제의 핵심은 모든 경우의 수를 탐색해야 문제를 풀 수 있다는 것을 알려준다.

* * *
2021년 4월 2주차(2021-04-11 ~ 2021-04-17)
1) [코딩테스트 연습 - 소수 찾기](https://programmers.co.kr/learn/courses/30/lessons/42839)
+ 풀이) 재미있는 문제다. 

1. 문자열을 각 자리수를 나타내는 정수배열로 변환
2. 정수배열을 내림차순으로 정렬
3. 배열의 크기만큼 자리수를 형성하는 가장 큰 값 구함
ex) 1,2,3 → 321
4. 가장 큰 값까지의 모든 소수 구함
5. 정수배열을 조합하였을 시 모든 경우의 수 구함
6. 모든 경우의 수에 대해서 ④에서 구했던 소수와 비교하여 소수일경우 체크 

2) [코딩테스트 연습 - 모의고사](https://programmers.co.kr/learn/courses/30/lessons/42840)
+ 풀이) 
1. 문제에서 수포자1, 2, 3이 수학문제를 찍는 순서가 반복됨을 알 수 있습니다.  
1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 

2. 각 수포자의 한 싸이클의 찍는 순서를 List에 저장합니다. for문을 통해 정답(answers) 배열을 탐색할 때 각 수포자의 찍는 순서 %연산자를 통해 순환하여 탐색하며 정답과 일치하는 개수를 Map<수포자 ID, 정답과 일치 개수>에 저장합니다.
Map을 정답과 일치하는 개수를 기준으로 내림차순 정렬한 후 일치하는 개수가 같을경우 수포자의 ID를 기준으로 오름차순 정렬합니다.

* * *
2021년 4월 3주차(2021-04-18 ~ 2021-04-24)
1) [코딩테스트 연습 - 두 개 뽑아서 더하기](https://programmers.co.kr/learn/courses/30/lessons/68644)
+ 풀이) 배열의 원소들을 모두 더하기 위해서 이중 for문을 통해 구현했습니다.
더해진 수들을 Set 자료구조에 넣어 중복되지 않도록 구현했으며, JAVA의 Tim Sort로 값들을 오름차순 정렬하였습니다.


2) [코딩테스트 연습 - 구명보트](https://programmers.co.kr/learn/courses/30/lessons/42885)
+ 풀이)
투 포인트 문제이며 보트에 탈수 있는 최대 인원이 2명인게 핵심이다.
만약 2명이 아니라면 heap을 사용해야할 것 같다.
1. people을 오름차순으로 정렬한다.
2. 가장 무게가 적은 사람을 가리키는 left, 가장 무게가 많은 사람을 가리키는 right 변수 선언한다.
3. 가장 무게가 적은 사람과 가장 많은 사람의 합이 limit보다 작은지 확인한다.
4. 만약 작다면 두 사람 모두 보트에 탈 수 있어 보트 수를 1 증가시킨다. 두 사람이 모두 탔기에 left를 1 증가시키고 right를 1 감소시킨다.
5. 만약 크다면 무게가 많은 사람만이 탈 수 있으므로 마찬가지로 보트 수를 1 증가시키며 right를 1 감소시킨다.
6. 양쪽의 변수가 교차될 때까지 반복한다.

* * *
2021년 4월 4주차(2021-04-25 ~ 2021-05-01)
1) [코딩테스트 연습 - 가장 큰 수](https://programmers.co.kr/learn/courses/30/lessons/42746)
+ 풀이) 
1. 배열의 가장 큰 수의 자리수를 구한다
2. 2차원 배열을 선언하여 0번째 자리에는 원래의 수를 1번째 자리에는 가공된 수를 추가한다.
3. 가공된 수란? 만약 가장 큰 수의 자리수보다 자리수가 작은 값일경우 첫번째 값을 가장 큰 수의 자리수가 될때까지 추가한 수를 의미한다.
4. 첫번째로 가공된 수, 두번째로 두 수를 더하여 큰 수를 기준으로 merge(n logn) 정렬한다.
5. 정렬된 수를 StringBuilder에 추가한 후 출력하는데 시작되는 숫자가 0이 아닌 수가 나올 때까지 0을 제거한다.  

2) [코딩테스트 연습 - K번째수](https://programmers.co.kr/learn/courses/30/lessons/42748)
+ 풀이) 우선 commands를 순회할 때 i, j, k 값을 추출하며 Java API에서 제공하는 System 클래스의 arraycopy 함수를 사용하여 시작 인덱스로부터 길이까지의 배열을 복사한다.
복사된 배열을 오름차순으로 정렬 후 k번째의 값을 가져온다. 

2021년 5월 1주차(2021.05.02 ~ 2021.05.09) - javascript로 문제풀음
1) [코딩테스트 연습 - 큰 수 만들기](https://programmers.co.kr/learn/courses/30/lessons/42883)
+ 풀이) 
1. Deque라는 자료구조를 활용한다. 
IIFE를 통해 Deque라는 자료구조 선언
2. 배열을 순회하면서 Deque의 마지막에 존재하는 값과 비교를 통해 현재의 값이 작다면 Deque에 추가하고 크다면 Deque의 값을 제거한다.
3. 순회 작업이 끝났을 때 Deque에 있는 자릿수가 구하고자하는 자릿수보다 클 경우 Deque의 마지막 부분부터 제거한다
이유 : Deque에 존재하는 자릿수가 더 크다는 것은 Deque에 먼저 들어간 숫자가 뒤에 들어간 숫자보다 크거나 같다는 의미이다. 고정된 자릿수에서 최대값을 구하기 위해 앞에서부터 제거하는것이 아닌 뒤에서부터 제거한다.

2) [코딩테스트 연습 - 영어 끝말잇기](https://programmers.co.kr/learn/courses/30/lessons/12981)
+ 풀이) 
1. reduce를 이용하여 이전값과 현재값이 끝말잇기가 되는지 비교한다. 
끝말잇기가 되지 않을경우 answer에 값을 넣는다.
2. find 메소드를 통해 현재의 값이 이전에 존재하는지 확인한다.
자바스크립트에서 Set or Map을 사용하면 성능에 저하가 발생한다는 말이 있기 때문에 Map을 사용하지 않는다.
